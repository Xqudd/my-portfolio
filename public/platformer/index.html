<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Platformer</title>

  <style>
    body { 
      margin: 0; 
      overflow: hidden;
      background: #87CEEB;
      font-family: sans-serif;
    }
    #game {
      position: absolute;
      width: 100vw;
      height: 100vh;
      background: #222;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 22px;
      font-weight: bold;
    }
  </style>
</head>

<body>
<canvas id="game"></canvas>
<div id="ui">Coins: 0</div>

<script>
/* ===========================================================
   CONFIG
=========================================================== */
(function startPlatformer() {
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let cameraX = 0;
canvas.width = innerWidth;
canvas.height = innerHeight;

// Physics
const GRAVITY = 0.6;
const JUMP = -15;
const MOVE = 5;

// Level generation
const PLATFORM_COUNT = 6;
const COINS_PER_LEVEL = 3;

// Parallax background layers
const bgLayers = [
  { speed: 0.2, color: "#66b3ff" },
  { speed: 0.5, color: "#3399ff" },
  { speed: 1.0, color: "#0066cc" }
];

let keys = {};
let platforms = [];
let coins = [];
let hazards = [];
let staticPlatforms = [];
let movingPlatforms = [];


let coinCount = 0;

window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);

/* ===========================================================
   PLAYER
=========================================================== */
const player = {
  x: 200,
  y: 0,
  w: 40,
  h: 50,
  vx: 0,
  vy: 0,
  grounded: false,
  alive: true,
};
/* ===========================================================
   PARTICLES
=========================================================== */
let particles = [];

function addParticles(x, y, count, color) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 4,
      vy: -Math.random() * 2,
      life: 20,
      color
    });
  }
}

/* ===========================================================
   PLATFORM & LEVEL GENERATION
=========================================================== */

function random(min, max) {
  return Math.random() * (max - min) + min;
}

function generateLevel() {
  staticPlatforms = [];
  movingPlatforms = [];
  coins = [];
  hazards = [];

  // Starting platform
  staticPlatforms.push({ x: 50, y: 400, w: 120, h: 20 });

  let lastX = 50;
  let lastY = 400;
  const platformCount = 7;
  const minGapX = 150;
  const maxGapX = 300;
  const minGapY = -120;
  const maxGapY = 120;

  for (let i = 0; i < platformCount; i++) {
    // Horizontal + vertical offsets
    const gapX = minGapX + Math.random() * (maxGapX - minGapX);
    let gapY = minGapY + Math.random() * (maxGapY - minGapY);
    let newX = lastX + gapX;
    let newY = lastY + gapY;
    newY = Math.min(450, Math.max(120, newY));

    // Randomly moving or static
    const isMoving = Math.random() < 0.35;
    if (isMoving) {
      movingPlatforms.push({
        x: newX,
        y: newY,
        w: 120,
        h: 20,
        dir: 1,
        x0: newX,
        range: 80
      });
    } else {
      staticPlatforms.push({ x: newX, y: newY, w: 120, h: 20 });
    }

    // Coin for this platform
    coins.push({ x: newX + 60, y: newY - 25, r: 10, collected: false });

    // Optional hazard below platform
    if (Math.random() < 0.3) {
      hazards.push({ x: newX, y: newY + 40, w: 60, h: 20 });
    }

    lastX = newX;
    lastY = newY;
  }

  // Ensure last coin is on the last platform
  coins[coins.length - 1] = {
    x: lastX + 60,
    y: lastY - 25,
    r: 10,
    collected: false
  };

  // Take only 3 coins, but keep last coin on last platform
  const lastCoin = coins[coins.length - 1];
  coins = coins.sort(() => Math.random() - 0.5).slice(0, 2);
  coins.push(lastCoin);

  // Reset player
  player.x = 50;
  player.y = 370;
  player.vx = 0;
  player.vy = 0;
  player.alive = true;
}


/* ===========================================================
   CAMERA
=========================================================== */


function updateCamera() {
  const targetX = player.x - canvas.width / 3;
  cameraX += (targetX - cameraX) * 0.1;
}

/* ===========================================================
   UPDATE LOOP
=========================================================== */

function update() {
  if (!player.alive) {
  draw();       // Still draw particles + death animation
  requestAnimationFrame(update);
  return;
}


  // Physics
  player.vy += GRAVITY;
  player.x += (keys["a"] || keys["ArrowLeft"] ? -MOVE : 0)
           + (keys["d"] || keys["ArrowRight"] ? MOVE : 0);
  player.y += player.vy;

  // Jump
  if ((keys[" "] || keys["w"] || keys["ArrowUp"]) && player.grounded) {
    player.vy = JUMP;
    player.grounded = false;
    addParticles(player.x + player.w/2, player.y + player.h, 10, "white");
  }

  // Platform collision
  player.grounded = false;
[...staticPlatforms, ...movingPlatforms].forEach(p => {
  if (
    player.x < p.x + p.w &&
    player.x + player.w > p.x &&
    player.y < p.y + p.h &&
    player.y + player.h > p.y
  ) {
    if (player.vy > 0) {
      player.y = p.y - player.h;
      player.vy = 0;
      player.grounded = true;
    }
  }
});


  // Moving platforms motion
  for (const mp of movingPlatforms) {
    mp.x += mp.dir * 1.2;
    if (mp.x > mp.x0 + mp.range || mp.x < mp.x0 - mp.range) {
      mp.dir *=  -1;
    }
  }

  // Hazards
  for (const h of hazards) {
    if (player.x < h.x + h.w &&
        player.x + player.w > h.x &&
        player.y + player.h > h.y &&
        player.y < h.y + h.h) {
      killPlayer();
    }
  }

  // Coins
  for (let i = coins.length - 1; i >= 0; i--) {
    const c = coins[i];
    if (Math.hypot((player.x - c.x), (player.y - c.y)) < 40) {
      coins.splice(i, 1);
      coinCount++;
      document.getElementById("ui").textContent = "Coins: " + coinCount;

      // If all coins collected → new level
      if (coins.length === 0) {
        generateLevel();
      }
    }
  }

  // Fell off screen → restart
  if (player.y > canvas.height || hazards.some(h => 
    player.x < h.x + h.w &&
    player.x + player.w > h.x &&
    player.y < h.y + h.h &&
    player.y + player.h > h.y
)) {
  generateLevel();
}


  updateCamera();
  updateParticles();
  draw();
  requestAnimationFrame(update);
}

/* ===========================================================
   PARTICLES UPDATE
=========================================================== */
function updateParticles() {
  particles = particles.filter(p => p.life-- > 0);
  for (const p of particles) {
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.1;
  }
}

/* ===========================================================
   DEATH
=========================================================== */
let deathTimer = null;

function killPlayer() {
  if (!player.alive) return; // Prevent double-death triggers
  player.alive = false;
  addParticles(player.x, player.y, 40, "red");

  // Stop movement immediately
  player.vx = 0;
  player.vy = 0;

  // Schedule restart ONCE
  clearTimeout(deathTimer);
  deathTimer = setTimeout(() => {
    generateLevel();
  }, 800);
}


function restartAfterDeath() {
  setTimeout(() => {
    generateLevel();
  }, 800);
}

/* ===========================================================
   RENDERING
=========================================================== */
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Background layers (parallax)
  for (let i = 0; i < bgLayers.length; i++) {
    ctx.fillStyle = bgLayers[i].color;
    ctx.fillRect(-cameraX * bgLayers[i].speed, 0, canvas.width * 2, canvas.height);
  }

  ctx.save();
  ctx.translate(-cameraX, 0);

  // Platforms
  ctx.fillStyle = "#444";
  staticPlatforms.forEach(p => ctx.fillRect(p.x, p.y, p.w, p.h));

  ctx.fillStyle = "#666";
  movingPlatforms.forEach(mp => ctx.fillRect(mp.x, mp.y, mp.w, mp.h));


  // Hazards
  ctx.fillStyle = "red";
  for (const h of hazards) {
    ctx.fillRect(h.x, h.y, h.w, h.h);
  }

  // Coins
  ctx.fillStyle = "yellow";
  for (const c of coins) {
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
    ctx.fill();
  }

  // Player
  ctx.fillStyle = player.alive ? "white" : "red";
  ctx.fillRect(player.x, player.y, player.w, player.h);

  // Particles
  for (const p of particles) {
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, 3, 3);
  }

  ctx.restore();
}

/* ===========================================================
   INIT
=========================================================== */
generateLevel();
update();
})();
</script>

</body>
</html>
